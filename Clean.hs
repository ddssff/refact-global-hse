{-# LANGUAGE CPP #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TupleSections #-}
{-# OPTIONS -Wall #-}

module Clean (cleanImports) where

import CPP (cppEndif, cppIf, extensionsForHSEParser, GHCOpts(..), ghcProcessArgs)
import Control.Monad (void, when)
import Control.Monad.RWS (MonadWriter(tell))
import Data.List (find, transpose)
import Data.Monoid ((<>))
import Data.Set as Set (empty, member, Set, singleton, union, unions)
import Debug.Trace (trace)
import Imports (mergeDecls)
import qualified Language.Haskell.Exts.Annotated as A (Decl(DerivDecl), ImportDecl(ImportDecl, importAs, importModule, importQualified, importSpecs), ImportSpec(IAbs, IThingAll, IThingWith, IVar), ImportSpecList(ImportSpecList), InstHead(..), InstRule(..), Module(Module, XmlHybrid, XmlPage), ModuleHead(ModuleHead), ModuleName(..), Name, QName(Qual, UnQual), Type(..))
import Language.Haskell.Exts.SrcLoc (SrcInfo, SrcSpanInfo)
import LoadModule (loadModule)
import ModuleInfo (ModuleInfo(..))
import ModuleKey (moduleFullPath)
import SrcLoc (EndLoc, endOfImports, keep, keepAll, ScanM, scanModule, skip, startOfDecls, startOfImports, withTrailingWhitespace)
import System.FilePath ((</>))
import System.IO (hPutStrLn, stderr)
import System.Process (readProcess)
import Utils (ezPrint, prettyPrint', replaceFile, simplify, withTempDirectory)

-- | Run ghc with -ddump-minimal-imports and capture the resulting .imports file.
cleanImports :: [GHCOpts] -> [ModuleInfo SrcSpanInfo] -> IO ()
cleanImports _ [] = trace ("cleanImports - no modules") (pure ())
cleanImports optSets mods = do
  imodSets <- mapM (doOpts mods) optSets :: IO [[(GHCOpts, [A.ImportDecl SrcSpanInfo])]]
  mapM_ (uncurry doModule) (zip mods (transpose imodSets))

doOpts :: [ModuleInfo SrcSpanInfo] -> GHCOpts -> IO [(GHCOpts, [A.ImportDecl SrcSpanInfo])]
doOpts mods opts =
    withTempDirectory True "." "scratch" $ \scratch -> do
         hPutStrLn stderr ("cleanImports: " ++ ezPrint opts ++ " (scratch=" ++ scratch ++ ")")
         let args' = ["--make", "-c", "-ddump-minimal-imports", "-outputdir", scratch] ++
                     ghcProcessArgs (opts {enabled = enabled opts ++ extensionsForHSEParser}) ++
                     map _modulePath mods
         _out <- readProcess (hc opts) args' ""
         map (opts,) <$> mapM (newImports opts scratch) mods

doModule :: ModuleInfo SrcSpanInfo -> [(GHCOpts, [A.ImportDecl SrcSpanInfo])] -> IO ()
doModule m pairs =
    do let newText = newModuleText m pairs
       let path = moduleFullPath (_moduleKey m)
       case newText of
         Nothing -> putStrLn (path <> " - imports already clean")
         Just s | _moduleText m /= s -> do
                      putStrLn (" imports changed")
                      void $ replaceFile path s
         Just _ -> pure ()

-- | Load the minimized imports output by ghc as a module.
newImports :: GHCOpts -> FilePath -> ModuleInfo SrcSpanInfo -> IO [A.ImportDecl SrcSpanInfo]
newImports opts scratch (ModuleInfo {_module = A.Module _ mh _ _ _}) = do
  (\(ModuleInfo {_module = A.Module _ _ _ is _}) -> is) <$> loadModule opts importsPath
    where
      moduleName = maybe "Main" (\ (A.ModuleHead _ (A.ModuleName _ s) _ _) -> s) mh
      importsPath = scratch </> moduleName ++ ".imports"
newImports _ _ _ = error "Unsupported module type"

-- | Parse the import list generated by GHC, parse the original source
-- file, and if all goes well insert the new imports into the old
-- source file.  We also need to modify the imports of any names
-- that are types that appear in standalone instance derivations so
-- their members are imported too.
newModuleText :: forall l. (SrcInfo l, EndLoc l, Eq l) => ModuleInfo l -> [(GHCOpts, [A.ImportDecl l])] -> Maybe String
newModuleText mi@(ModuleInfo {_module = m@(A.Module _ _ _ oi _)}) pairs =
    Just $ scanModule (do keep (startOfImports mi)
                          mapM_ (uncurry doOptImports) (fixNewImports True mi pairs)
                          when (not (null oi)) (skip (endOfImports m))
                          withTrailingWhitespace skip (startOfDecls mi)
                          keepAll) mi
    where
      doOptImports :: GHCOpts -> [A.ImportDecl l] -> ScanM ()
      doOptImports opts ni =
          -- let ni'' = fixNewImports' True mi ni in
          -- if simplify oi == map simplify ni' then keep ... else
          do tell (cppIf opts)
             tell (unlines (map prettyPrint' ni))
             tell (cppEndif opts)
newModuleText _ _ = error "Unsupported module type"

fixNewImports :: (SrcInfo l, Eq l) => Bool -> ModuleInfo l -> [(GHCOpts, [A.ImportDecl l])] -> [(GHCOpts, [A.ImportDecl l])]
fixNewImports remove mi pairs = map (\(opts, ni) -> (opts, fixNewImports' remove mi ni)) pairs

-- | Final touch-ups - sort and merge similar imports.
fixNewImports' :: forall l. (SrcInfo l, Eq l) =>
                  Bool         -- ^ If true, imports that turn into empty lists will be removed
               -> ModuleInfo l
               -> [A.ImportDecl l]
               -> [A.ImportDecl l]
fixNewImports' remove mi@(ModuleInfo {_module = A.Module _ _ _ oi _}) ni =
    filter importPred $ map expandSDTypes $ mergeDecls $ ni ++ filter isHidingImport oi
    where
      expandSDTypes :: A.ImportDecl l -> A.ImportDecl l
      expandSDTypes i@(A.ImportDecl {A.importSpecs = Just (A.ImportSpecList l f specs)}) =
          i {A.importSpecs = Just (A.ImportSpecList l f (Prelude.map (expandSpec i) specs))}
      expandSDTypes i = i
      expandSpec i s =
          if not (A.importQualified i) && member (Nothing, simplify n) sdTypes ||
             maybe False (\ mn -> (member (Just (simplify mn), simplify n) sdTypes)) (A.importAs i) ||
             member (Just (simplify (A.importModule i)), simplify n) sdTypes
          then s'
          else s
          where
            n = case s of
                  (A.IVar _ x) -> x
                  (A.IAbs _ _ x) -> x
                  (A.IThingAll _ x) -> x
                  (A.IThingWith _ x _) -> x
            s' = case s of
                  (A.IVar l x) -> A.IThingAll l x
                  (A.IAbs l _ x) -> A.IThingAll l x
                  (A.IThingWith l x _) -> A.IThingAll l x
                  (A.IThingAll _ _) -> s

      -- Eliminate imports that became empty
      -- importPred :: ImportDecl -> Bool
      importPred (A.ImportDecl _ mn _ _ _ _ _ (Just (A.ImportSpecList _ _ []))) =
          not remove || maybe False (isEmptyImport . A.importSpecs) (find ((== (simplify mn)) . simplify . A.importModule) oi)
          where
            isEmptyImport (Just (A.ImportSpecList _ _ [])) = True
            isEmptyImport _ = False
      importPred _ = True

      sdTypes :: Set (Maybe (A.ModuleName ()), A.Name ())
      sdTypes = standaloneDerivingTypes mi
fixNewImports' _ _ _ = error "Unexpected module type"

isHidingImport :: A.ImportDecl l -> Bool
isHidingImport (A.ImportDecl {A.importSpecs = Just (A.ImportSpecList _ True _)}) = True
isHidingImport _ = False

standaloneDerivingTypes :: ModuleInfo l -> Set (Maybe (A.ModuleName ()), A.Name ())
standaloneDerivingTypes (ModuleInfo {_module = A.XmlPage _ _ _ _ _ _ _}) = error "standaloneDerivingTypes A.XmlPage"
standaloneDerivingTypes (ModuleInfo {_module = A.XmlHybrid _ _ _ _ _ _ _ _ _}) = error "standaloneDerivingTypes A.XmlHybrid"
standaloneDerivingTypes (ModuleInfo {_module = A.Module _ _ _ _ decls}) =
    unions (Prelude.map derivDeclTypes decls)

-- | Collect the declared types of a standalone deriving declaration.
class DerivDeclTypes a where
    derivDeclTypes :: a -> Set (Maybe (A.ModuleName ()), A.Name ())

instance DerivDeclTypes (A.Decl l) where
    derivDeclTypes (A.DerivDecl _ _ x) = derivDeclTypes x
    derivDeclTypes _ = empty

instance DerivDeclTypes (A.InstRule l) where
    derivDeclTypes (A.IRule _ _ _ x)  = derivDeclTypes x
    derivDeclTypes (A.IParen _ x) = derivDeclTypes x

instance DerivDeclTypes (A.InstHead l) where
    derivDeclTypes (A.IHCon _ _) = empty
    derivDeclTypes (A.IHParen _ x) = derivDeclTypes x
    derivDeclTypes (A.IHInfix _ x _op) = derivDeclTypes x
    derivDeclTypes (A.IHApp _ x y) = union (derivDeclTypes x) (derivDeclTypes y)

instance DerivDeclTypes (A.Type l) where
    derivDeclTypes (A.TyForall _ _ _ x) = derivDeclTypes x -- qualified type
    derivDeclTypes (A.TyFun _ x y) = union (derivDeclTypes x) (derivDeclTypes y) -- function type
    derivDeclTypes (A.TyTuple _ _ xs) = unions (Prelude.map derivDeclTypes xs) -- tuple type, possibly boxed
    derivDeclTypes (A.TyList _ x) =  derivDeclTypes x -- list syntax, e.g. [a], as opposed to [] a
    derivDeclTypes (A.TyApp _ x y) = union (derivDeclTypes x) (derivDeclTypes y) -- application of a type constructor
    derivDeclTypes (A.TyVar _ _) = empty -- type variable
    derivDeclTypes (A.TyCon _ (A.Qual _ m n)) = singleton (Just (simplify m), simplify n) -- named type or type constructor
       -- Unqualified names refer to imports without "qualified" or "as" values.
    derivDeclTypes (A.TyCon _ (A.UnQual _ n)) = singleton (Nothing, simplify n)
    derivDeclTypes (A.TyCon _ _) = empty
    derivDeclTypes (A.TyParen _ x) = derivDeclTypes x -- type surrounded by parentheses
    derivDeclTypes (A.TyInfix _ x _op y) = union (derivDeclTypes x) (derivDeclTypes y) -- infix type constructor
    derivDeclTypes (A.TyKind _ x _) = derivDeclTypes x -- type with explicit kind signature
    derivDeclTypes (A.TyParArray _ x) = derivDeclTypes x
    derivDeclTypes (A.TyPromoted _ _) = empty
    derivDeclTypes (A.TyEquals _ _ _) = empty -- a ~ b, not clear how this related to standalone deriving
    derivDeclTypes (A.TySplice _ _) = empty
    derivDeclTypes (A.TyBang _ _ x) = derivDeclTypes x
    derivDeclTypes (A.TyWildCard _ _) = empty
